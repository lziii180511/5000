<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Curve Fitting Tool</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: #f5f5f5; overflow: hidden; }
        #container { width: 100vw; height: 100vh; display: flex; flex-direction: column; }
        #toolbar { background: white; padding: 10px 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; gap: 6px; flex-wrap: wrap; align-items: center; position: relative; }
        button { padding: 6px 12px; border: none; border-radius: 6px; background: #007AFF; color: white; font-size: 12px; cursor: pointer; }
        button:active { opacity: 0.8; }
        #clear { background: #FF3B30; }
        #undo, #redo { background: #5856D6; font-size: 14px; padding: 6px 10px; }
        #mode { background: #007AFF; }
        #mode.active { background: #0051D5; box-shadow: 0 0 0 2px rgba(0,81,213,0.3); }
        #geometry { background: #FF9500; }
        #geometry.active { background: #CC7700; box-shadow: 0 0 0 2px rgba(204,119,0,0.3); }
        #polygon { background: #AF52DE; }
        #polygon.active { background: #8B3DB0; box-shadow: 0 0 0 2px rgba(139,61,176,0.3); }
        #freehand { background: #000; }
        #freehand.active { background: #333; box-shadow: 0 0 0 2px rgba(0,0,0,0.3); }
        #eraser { background: #1C1C1E; }
        #eraser.active { background: #3A3A3C; box-shadow: 0 0 0 2px rgba(0,0,0,0.3); }
        #toggleStroke { background: #8E8E93; }
        #colorPicker { display: none; gap: 4px; align-items: center; }
        #colorPicker.show { display: flex; }
        .color-opt { width: 20px; height: 20px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: transform 0.1s; }
        .color-opt:hover { transform: scale(1.15); }
        .color-opt.selected { border-color: #007AFF; }
        .right-buttons { position: absolute; right: 12px; top: 50%; transform: translateY(-50%); display: flex; gap: 6px; align-items: center; }
        #canvasContainer { flex: 1; position: relative; overflow: hidden; background: white; touch-action: none; }
        #canvas { position: absolute; top: 0; left: 0; touch-action: none; }
        #eraserCursor { position: absolute; pointer-events: none; border: 2px solid #FF3B30; border-radius: 50%; display: none; z-index: 100; }
        #zoomControls { position: absolute; bottom: 15px; right: 15px; display: flex; gap: 6px; align-items: center; background: rgba(255,255,255,0.95); padding: 8px 12px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.15); z-index: 50; }
        #zoomControls button { background: #5856D6; }
        #zoomLevel { font-size: 12px; color: #666; min-width: 45px; text-align: center; }
        #status { padding: 6px; background: #fff; border-top: 1px solid #ddd; text-align: center; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div id="container">
        <div id="toolbar">
            <button id="clear">Clear</button>
            <button id="undo" title="Undo">↶</button>
            <button id="redo" title="Redo">↷</button>
            <button id="mode">Curve</button>
            <button id="geometry">Conic</button>
            <button id="polygon">Polygon</button>
            <button id="freehand">Freehand</button>
            <button id="eraser">Eraser</button>
            <div id="colorPicker"></div>
            <div class="right-buttons">
                <button id="toggleStroke">Hide Stroke</button>
                <button id="langBtn">Language</button>
            </div>
        </div>
        <div id="canvasContainer">
            <canvas id="canvas"></canvas>
            <div id="eraserCursor"></div>
            <div id="zoomControls">
                <button id="zoomOut">−</button>
                <span id="zoomLevel">100%</span>
                <button id="zoomIn">+</button>
                <button id="resetZoom">Reset</button>
            </div>
        </div>
        <div id="status">Select a tool and draw on the canvas</div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const colorPickerDiv = document.getElementById('colorPicker');
        const eraserCursor = document.getElementById('eraserCursor');
        
        const ERASER_RADIUS = 15;
        
        let lang = 'en';
        const texts = {
            en: {
                clear: 'Clear', curve: 'Curve', conic: 'Conic', polygon: 'Polygon',
                hideStroke: 'Hide Stroke', showStroke: 'Show Stroke', reset: 'Reset',
                freehand: 'Freehand', freehandColor: 'Freehand-color',
                eraser: 'Eraser',
                edit: 'Edit', lang: 'Language',
                statusDefault: 'Select a tool and draw on the canvas',
                statusCleared: 'Canvas cleared',
                statusFreehand: 'Freehand stroke added',
                statusCurve: 'Curve: draw and hold 0.5s to fit',
                statusConic: 'Conic: draw and hold 0.5s to recognize',
                statusPolygon: 'Polygon: draw and hold 0.5s to recognize',
                statusFreehandTip: 'Freehand: draw freely, click again for colors',
                statusEraser: 'Eraser: touch strokes to delete them',
                fitted: 'Fitted', segments: 'segment(s)', recognized: 'Recognized'
            },
            zh: {
                clear: '清除', curve: '曲线', conic: '圆锥曲线', polygon: '正多边形',
                hideStroke: '隐藏笔迹', showStroke: '显示笔迹', reset: '重置',
                freehand: '手写', freehandColor: '手写-颜色',
                eraser: '橡皮',
                edit: '编辑', lang: '语言',
                statusDefault: '选择工具并在画布上绘制',
                statusCleared: '画布已清除',
                statusFreehand: '已添加手写笔画',
                statusCurve: '曲线：绘制并保持0.5秒以拟合',
                statusConic: '圆锥曲线：绘制并保持0.5秒以识别',
                statusPolygon: '正多边形：绘制并保持0.5秒以识别',
                statusFreehandTip: '手写：自由绘制，再次点击选择颜色',
                statusEraser: '橡皮：触碰笔画以删除',
                fitted: '已拟合', segments: '段', recognized: '已识别'
            }
        };
        
        function t(key) { return texts[lang][key] || key; }
        
        function updateLanguage() {
            document.getElementById('clear').textContent = t('clear');
            document.getElementById('resetZoom').textContent = t('reset');
            document.getElementById('langBtn').textContent = t('lang');
            document.getElementById('toggleStroke').textContent = showStroke ? t('hideStroke') : t('showStroke');
            document.getElementById('eraser').textContent = t('eraser');
            updateButtons();
        }
        
        const colors = ['#000000','#FF3B30','#FF9500','#FFCC00','#34C759','#007AFF','#5856D6','#AF52DE','#8E8E93'];
        colors.forEach((c, i) => {
            const div = document.createElement('div');
            div.className = 'color-opt' + (i === 0 ? ' selected' : '');
            div.style.background = c;
            div.onclick = () => {
                document.querySelectorAll('.color-opt').forEach(d => d.classList.remove('selected'));
                div.classList.add('selected');
                freehandColor = c;
            };
            colorPickerDiv.appendChild(div);
        });

        let currentTool = 'bezier';
        let editMode = false;
        let showStroke = true;
        let freehandColor = '#000000';
        let colorPickerVisible = false;
        
        let allStrokes = [];
        let currentPoints = [];
        let editingStrokeIdx = -1;
        
        let historyStack = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;
        
        let zoom = 1, offsetX = 0, offsetY = 0;
        let dragging = null, panning = false, lastX = 0, lastY = 0, lastMove = 0;
        let activePointerId = null;
        
        let activeTouches = {};
        let isPinching = false;
        let lastPinchDist = 0;
        let lastPinchCenter = { x: 0, y: 0 };
        
        let isErasing = false;
        
        const BASE_GRID_SIZE = 50;

        function saveState() {
            const state = JSON.stringify({
                allStrokes: allStrokes,
                editMode: editMode,
                editingStrokeIdx: editingStrokeIdx,
                currentTool: currentTool
            });
            historyStack = historyStack.slice(0, historyIndex + 1);
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }
            historyIndex = historyStack.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(historyStack[historyIndex]);
            }
        }

        function redo() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                restoreState(historyStack[historyIndex]);
            }
        }

        function restoreState(stateStr) {
            const state = JSON.parse(stateStr);
            allStrokes = state.allStrokes;
            editMode = state.editMode;
            editingStrokeIdx = state.editingStrokeIdx;
            updateButtons();
            draw();
        }

        saveState();

        function updateButtons() {
            ['mode', 'geometry', 'polygon', 'freehand', 'eraser'].forEach(id => {
                document.getElementById(id).classList.remove('active');
            });
            
            const modeBtn = document.getElementById('mode');
            const geometryBtn = document.getElementById('geometry');
            const polygonBtn = document.getElementById('polygon');
            const freehandBtn = document.getElementById('freehand');
            const eraserBtn = document.getElementById('eraser');
            
            if (currentTool === 'bezier') {
                modeBtn.classList.add('active');
                if (editMode) {
                    modeBtn.textContent = t('curve') + ' ✎';
                } else if (allStrokes.some(s => s.tool === 'bezier' && s.result)) {
                    modeBtn.textContent = t('edit');
                } else {
                    modeBtn.textContent = t('curve');
                }
            } else {
                modeBtn.textContent = t('curve');
            }
            
            if (currentTool === 'geometry') {
                geometryBtn.classList.add('active');
                if (editMode) {
                    geometryBtn.textContent = t('conic') + ' ✎';
                } else if (allStrokes.some(s => s.tool === 'geometry' && s.result)) {
                    geometryBtn.textContent = t('edit');
                } else {
                    geometryBtn.textContent = t('conic');
                }
            } else {
                geometryBtn.textContent = t('conic');
            }
            
            if (currentTool === 'polygon') {
                polygonBtn.classList.add('active');
                if (editMode) {
                    polygonBtn.textContent = t('polygon') + ' ✎';
                } else if (allStrokes.some(s => s.tool === 'polygon' && s.result)) {
                    polygonBtn.textContent = t('edit');
                } else {
                    polygonBtn.textContent = t('polygon');
                }
            } else {
                polygonBtn.textContent = t('polygon');
            }
            
            if (currentTool === 'freehand') {
                freehandBtn.classList.add('active');
                freehandBtn.textContent = colorPickerVisible ? t('freehand') : t('freehandColor');
            } else {
                freehandBtn.textContent = t('freehand');
            }
            
            if (currentTool === 'eraser') {
                eraserBtn.classList.add('active');
            }
            eraserBtn.textContent = t('eraser');
        }

        let initialized = false;

        function resize() {
            const r = canvas.parentElement.getBoundingClientRect();
            const scale = window.devicePixelRatio || 2;
            canvas.width = r.width * scale;
            canvas.height = r.height * scale;
            canvas.style.width = r.width + 'px';
            canvas.style.height = r.height + 'px';
            
            if (!initialized) {
                offsetX = canvas.width / 2;
                offsetY = canvas.height / 2;
                initialized = true;
            }
            
            draw();
        }
        window.addEventListener('resize', resize);
        resize();

        function drawGrid() {
            const scale = window.devicePixelRatio || 2;
            const w = canvas.width / scale;
            const h = canvas.height / scale;
            
            const originScreenX = offsetX / scale;
            const originScreenY = offsetY / scale;
            
            let gridSize = BASE_GRID_SIZE;
            
            const scaledGridSize = gridSize * zoom;
            if (scaledGridSize < 20) {
                const factor = Math.pow(2, Math.ceil(Math.log2(20 / scaledGridSize)));
                gridSize *= factor;
            } else if (scaledGridSize > 100) {
                const factor = Math.pow(2, Math.floor(Math.log2(scaledGridSize / 50)));
                gridSize /= factor;
            }
            
            const actualGridSize = gridSize * zoom;
            
            const startX = Math.floor(-originScreenX / actualGridSize) * actualGridSize;
            const startY = Math.floor(-originScreenY / actualGridSize) * actualGridSize;
            const endX = w - originScreenX;
            const endY = h - originScreenY;
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            
            for (let x = startX; x <= endX; x += actualGridSize) {
                const screenX = originScreenX + x;
                if (Math.abs(x) > 0.001) {
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, h);
                }
            }
            for (let y = startY; y <= endY; y += actualGridSize) {
                const screenY = originScreenY + y;
                if (Math.abs(y) > 0.001) {
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(w, screenY);
                }
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (originScreenX >= 0 && originScreenX <= w) {
                ctx.moveTo(originScreenX, 0);
                ctx.lineTo(originScreenX, h);
            }
            if (originScreenY >= 0 && originScreenY <= h) {
                ctx.moveTo(0, originScreenY);
                ctx.lineTo(w, originScreenY);
            }
            ctx.stroke();
            
            ctx.fillStyle = '#888';
            ctx.font = '11px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            for (let x = startX; x <= endX; x += actualGridSize) {
                const screenX = originScreenX + x;
                const value = Math.round(x / (BASE_GRID_SIZE * zoom) * 10) / 10;
                if (Math.abs(value) > 0.001 && screenX >= 20 && screenX <= w - 20) {
                    const labelY = Math.min(Math.max(originScreenY + 5, 5), h - 15);
                    ctx.fillText(value.toString(), screenX, labelY);
                }
            }
            
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let y = startY; y <= endY; y += actualGridSize) {
                const screenY = originScreenY + y;
                const value = -Math.round(y / (BASE_GRID_SIZE * zoom) * 10) / 10;
                if (Math.abs(value) > 0.001 && screenY >= 15 && screenY <= h - 15) {
                    const labelX = Math.min(Math.max(originScreenX - 5, 25), w - 5);
                    ctx.fillText(value.toString(), labelX, screenY);
                }
            }
            
            ctx.fillStyle = '#aaa';
            ctx.font = 'italic 14px -apple-system, sans-serif';
            
            if (originScreenX >= 0 && originScreenX <= w) {
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';
                ctx.fillText('y', originScreenX - 8, 8);
            }
            
            if (originScreenY >= 0 && originScreenY <= h) {
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';
                ctx.fillText('x', w - 8, originScreenY + 8);
            }
        }

        function draw() {
            const scale = window.devicePixelRatio || 2;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(scale, scale);
            
            drawGrid();
            
            ctx.save();
            ctx.translate(offsetX / scale, offsetY / scale);
            ctx.scale(zoom, zoom);
            
            allStrokes.forEach((stroke, idx) => {
                const isEditing = editMode && idx === editingStrokeIdx;
                drawStroke(stroke, isEditing);
            });
            
            if (currentPoints.length > 0) {
                ctx.strokeStyle = currentTool === 'freehand' ? freehandColor : '#999';
                ctx.lineWidth = (currentTool === 'freehand' ? 3 : 2) / zoom;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(currentPoints[0][0], currentPoints[0][1]);
                for (let i = 1; i < currentPoints.length; i++) {
                    ctx.lineTo(currentPoints[i][0], currentPoints[i][1]);
                }
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawStroke(stroke, isEditing) {
            if (showStroke && stroke.points.length > 0 && stroke.tool !== 'freehand') {
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1.5 / zoom;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(stroke.points[0][0], stroke.points[0][1]);
                for (let i = 1; i < stroke.points.length; i++) {
                    ctx.lineTo(stroke.points[i][0], stroke.points[i][1]);
                }
                ctx.stroke();
            }
            
            if (stroke.tool === 'freehand') {
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = 3 / zoom;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                if (stroke.points.length > 0) {
                    ctx.moveTo(stroke.points[0][0], stroke.points[0][1]);
                    for (let i = 1; i < stroke.points.length; i++) {
                        ctx.lineTo(stroke.points[i][0], stroke.points[i][1]);
                    }
                }
                ctx.stroke();
            } else if (stroke.tool === 'bezier' && stroke.result && stroke.result.segments) {
                stroke.result.segments.forEach(seg => {
                    const [p0, p1, p2, p3] = seg.controls;
                    ctx.strokeStyle = '#007AFF';
                    ctx.lineWidth = 3 / zoom;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p0[0], p0[1]);
                    ctx.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
                    ctx.stroke();
                    
                    if (isEditing) {
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = 1 / zoom;
                        ctx.setLineDash([5 / zoom, 5 / zoom]);
                        ctx.beginPath();
                        ctx.moveTo(p0[0], p0[1]);
                        ctx.lineTo(p1[0], p1[1]);
                        ctx.moveTo(p2[0], p2[1]);
                        ctx.lineTo(p3[0], p3[1]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        [p0, p3].forEach(p => {
                            ctx.fillStyle = '#34C759';
                            ctx.beginPath();
                            ctx.arc(p[0], p[1], 8 / zoom, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        [p1, p2].forEach(p => {
                            ctx.fillStyle = '#FF3B30';
                            ctx.beginPath();
                            ctx.arc(p[0], p[1], 8 / zoom, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                });
            } else if (stroke.tool === 'geometry' && stroke.result) {
                const geo = stroke.result;
                ctx.strokeStyle = '#FF9500';
                ctx.lineWidth = 3 / zoom;
                
                if (geo.type === 'circle') {
                    const [cx, cy, r] = geo.params;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    if (isEditing) {
                        ctx.fillStyle = '#FF3B30';
                        ctx.beginPath();
                        ctx.arc(cx, cy, 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(geo.startEnd[0], geo.startEnd[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (geo.type === 'ellipse') {
                    const [h, k, a, b, theta] = geo.params;
                    ctx.save();
                    ctx.translate(h, k);
                    ctx.rotate(theta);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                    
                    if (isEditing) {
                        ctx.fillStyle = '#FF3B30';
                        geo.foci.forEach(f => {
                            ctx.beginPath();
                            ctx.arc(f[0], f[1], 8 / zoom, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        ctx.beginPath();
                        ctx.arc(geo.startEnd[0], geo.startEnd[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (geo.type === 'parabola') {
                    const [a, b, c] = geo.params;
                    const xMin = Math.min(geo.start[0], geo.end[0]);
                    const xMax = Math.max(geo.start[0], geo.end[0]);
                    
                    ctx.beginPath();
                    for (let x = xMin; x <= xMax; x += 1) {
                        const y = a * x * x + b * x + c;
                        if (x === xMin) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    if (isEditing) {
                        ctx.fillStyle = '#FF3B30';
                        ctx.beginPath();
                        ctx.arc(geo.vertex[0], geo.vertex[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(geo.start[0], geo.start[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(geo.end[0], geo.end[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (stroke.tool === 'polygon' && stroke.result) {
                const poly = stroke.result;
                ctx.strokeStyle = '#AF52DE';
                ctx.lineWidth = 3 / zoom;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (poly.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(poly.start[0], poly.start[1]);
                    ctx.lineTo(poly.end[0], poly.end[1]);
                    ctx.stroke();
                    
                    if (isEditing) {
                        ctx.fillStyle = '#FF3B30';
                        ctx.beginPath();
                        ctx.arc(poly.start[0], poly.start[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(poly.end[0], poly.end[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (poly.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(poly.center[0], poly.center[1], poly.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    if (isEditing) {
                        ctx.fillStyle = '#FF3B30';
                        ctx.beginPath();
                        ctx.arc(poly.center[0], poly.center[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (poly.vertices) {
                    ctx.beginPath();
                    ctx.moveTo(poly.vertices[0][0], poly.vertices[0][1]);
                    for (let i = 1; i < poly.vertices.length; i++) {
                        ctx.lineTo(poly.vertices[i][0], poly.vertices[i][1]);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    
                    if (isEditing) {
                        ctx.fillStyle = '#FF3B30';
                        ctx.beginPath();
                        ctx.arc(poly.center[0], poly.center[1], 8 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                        poly.vertices.forEach(v => {
                            ctx.beginPath();
                            ctx.arc(v[0], v[1], 6 / zoom, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                }
            }
        }

        function toCanvas(clientX, clientY) {
            const r = canvas.getBoundingClientRect();
            const scale = window.devicePixelRatio || 2;
            const sx = (clientX - r.left) * scale;
            const sy = (clientY - r.top) * scale;
            return [(sx - offsetX) / zoom / scale, (sy - offsetY) / zoom / scale];
        }

        function toScreen(canvasX, canvasY) {
            const scale = window.devicePixelRatio || 2;
            const r = canvas.getBoundingClientRect();
            return [
                canvasX * zoom + offsetX / scale + r.left,
                canvasY * zoom + offsetY / scale + r.top
            ];
        }

        function findControlPoint(x, y) {
            if (editingStrokeIdx < 0) return null;
            const stroke = allStrokes[editingStrokeIdx];
            const r = 12 / zoom;
            
            if (stroke.tool === 'bezier' && stroke.result && stroke.result.segments) {
                for (let i = 0; i < stroke.result.segments.length; i++) {
                    for (let j = 0; j < 4; j++) {
                        const [px, py] = stroke.result.segments[i].controls[j];
                        if (Math.hypot(x - px, y - py) < r) return {type: 'bezier', seg: i, pt: j};
                    }
                }
            }
            
            if (stroke.tool === 'geometry' && stroke.result) {
                const geo = stroke.result;
                if (geo.type === 'circle') {
                    if (Math.hypot(x - geo.params[0], y - geo.params[1]) < r) return {type: 'circle_center'};
                    if (Math.hypot(x - geo.startEnd[0], y - geo.startEnd[1]) < r) return {type: 'circle_startEnd'};
                } else if (geo.type === 'ellipse') {
                    for (let i = 0; i < 2; i++) {
                        if (Math.hypot(x - geo.foci[i][0], y - geo.foci[i][1]) < r) return {type: 'ellipse_focus', idx: i};
                    }
                    if (Math.hypot(x - geo.startEnd[0], y - geo.startEnd[1]) < r) return {type: 'ellipse_startEnd'};
                } else if (geo.type === 'parabola') {
                    if (Math.hypot(x - geo.vertex[0], y - geo.vertex[1]) < r) return {type: 'parabola_vertex'};
                    if (Math.hypot(x - geo.start[0], y - geo.start[1]) < r) return {type: 'parabola_start'};
                    if (Math.hypot(x - geo.end[0], y - geo.end[1]) < r) return {type: 'parabola_end'};
                }
            }
            
            if (stroke.tool === 'polygon' && stroke.result) {
                const poly = stroke.result;
                if (poly.type === 'line') {
                    if (Math.hypot(x - poly.start[0], y - poly.start[1]) < r) return {type: 'line_start'};
                    if (Math.hypot(x - poly.end[0], y - poly.end[1]) < r) return {type: 'line_end'};
                } else if (poly.type === 'circle') {
                    if (Math.hypot(x - poly.center[0], y - poly.center[1]) < r) return {type: 'poly_circle_center'};
                } else if (poly.vertices) {
                    if (Math.hypot(x - poly.center[0], y - poly.center[1]) < r) return {type: 'poly_center'};
                    for (let i = 0; i < poly.vertices.length; i++) {
                        if (Math.hypot(x - poly.vertices[i][0], y - poly.vertices[i][1]) < r) return {type: 'poly_vertex', idx: i};
                    }
                }
            }
            return null;
        }

        function updateParabola(geo) {
            const s = geo.start, e = geo.end, v = geo.vertex;
            try {
                const A = [[s[0]*s[0], s[0], 1], [e[0]*e[0], e[0], 1], [v[0]*v[0], v[0], 1]];
                const B = [s[1], e[1], v[1]];
                const det = A[0][0]*(A[1][1]*A[2][2]-A[1][2]*A[2][1]) - A[0][1]*(A[1][0]*A[2][2]-A[1][2]*A[2][0]) + A[0][2]*(A[1][0]*A[2][1]-A[1][1]*A[2][0]);
                if (Math.abs(det) < 1e-10) return;
                const inv = [
                    [(A[1][1]*A[2][2]-A[1][2]*A[2][1])/det, (A[0][2]*A[2][1]-A[0][1]*A[2][2])/det, (A[0][1]*A[1][2]-A[0][2]*A[1][1])/det],
                    [(A[1][2]*A[2][0]-A[1][0]*A[2][2])/det, (A[0][0]*A[2][2]-A[0][2]*A[2][0])/det, (A[0][2]*A[1][0]-A[0][0]*A[1][2])/det],
                    [(A[1][0]*A[2][1]-A[1][1]*A[2][0])/det, (A[0][1]*A[2][0]-A[0][0]*A[2][1])/det, (A[0][0]*A[1][1]-A[0][1]*A[1][0])/det]
                ];
                geo.params = [inv[0][0]*B[0]+inv[0][1]*B[1]+inv[0][2]*B[2], inv[1][0]*B[0]+inv[1][1]*B[1]+inv[1][2]*B[2], inv[2][0]*B[0]+inv[2][1]*B[1]+inv[2][2]*B[2]];
            } catch(e) {}
        }

        function updateEllipse(geo) {
            const [f1, f2] = geo.foci;
            const h = (f1[0] + f2[0]) / 2, k = (f1[1] + f2[1]) / 2;
            const c = Math.hypot(f1[0] - f2[0], f1[1] - f2[1]) / 2;
            const a = geo.sumDist / 2;
            const b = Math.sqrt(Math.max(a * a - c * c, 1));
            const theta = Math.atan2(f1[1] - f2[1], f1[0] - f2[0]);
            geo.params = [h, k, a, b, theta];
            const ang = Math.atan2(geo.startEnd[1] - k, geo.startEnd[0] - h) - theta;
            geo.startEnd = [h + a*Math.cos(ang)*Math.cos(theta) - b*Math.sin(ang)*Math.sin(theta), k + a*Math.cos(ang)*Math.sin(theta) + b*Math.sin(ang)*Math.cos(theta)];
        }

        function updatePolygon(poly) {
            if (!poly.vertices) return;
            const cx = poly.center[0], cy = poly.center[1];
            const n = poly.sides;
            for (let i = 0; i < n; i++) {
                const angle = poly.rotation + 2 * Math.PI * i / n;
                poly.vertices[i] = [cx + poly.radius * Math.cos(angle), cy + poly.radius * Math.sin(angle)];
            }
        }

        // 检测点是否在笔画附近
        function pointNearStroke(x, y, stroke, threshold) {
            // 检查原始点
            if (stroke.points && stroke.points.length > 0) {
                for (let i = 0; i < stroke.points.length; i++) {
                    if (Math.hypot(x - stroke.points[i][0], y - stroke.points[i][1]) < threshold) {
                        return true;
                    }
                }
                // 检查线段
                for (let i = 0; i < stroke.points.length - 1; i++) {
                    if (pointToSegmentDist(x, y, stroke.points[i], stroke.points[i+1]) < threshold) {
                        return true;
                    }
                }
            }
            
            // 检查拟合结果
            if (stroke.tool === 'bezier' && stroke.result && stroke.result.segments) {
                for (const seg of stroke.result.segments) {
                    const [p0, p1, p2, p3] = seg.controls;
                    for (let t = 0; t <= 1; t += 0.05) {
                        const px = Math.pow(1-t,3)*p0[0] + 3*Math.pow(1-t,2)*t*p1[0] + 3*(1-t)*t*t*p2[0] + t*t*t*p3[0];
                        const py = Math.pow(1-t,3)*p0[1] + 3*Math.pow(1-t,2)*t*p1[1] + 3*(1-t)*t*t*p2[1] + t*t*t*p3[1];
                        if (Math.hypot(x - px, y - py) < threshold) return true;
                    }
                }
            }
            
            if (stroke.tool === 'geometry' && stroke.result) {
                const geo = stroke.result;
                if (geo.type === 'circle') {
                    const [cx, cy, r] = geo.params;
                    const dist = Math.abs(Math.hypot(x - cx, y - cy) - r);
                    if (dist < threshold) return true;
                } else if (geo.type === 'ellipse') {
                    const [h, k, a, b, theta] = geo.params;
                    for (let ang = 0; ang < Math.PI * 2; ang += 0.1) {
                        const px = h + a * Math.cos(ang) * Math.cos(theta) - b * Math.sin(ang) * Math.sin(theta);
                        const py = k + a * Math.cos(ang) * Math.sin(theta) + b * Math.sin(ang) * Math.cos(theta);
                        if (Math.hypot(x - px, y - py) < threshold) return true;
                    }
                } else if (geo.type === 'parabola') {
                    const [a, b, c] = geo.params;
                    const xMin = Math.min(geo.start[0], geo.end[0]);
                    const xMax = Math.max(geo.start[0], geo.end[0]);
                    for (let px = xMin; px <= xMax; px += 5) {
                        const py = a * px * px + b * px + c;
                        if (Math.hypot(x - px, y - py) < threshold) return true;
                    }
                }
            }
            
            if (stroke.tool === 'polygon' && stroke.result) {
                const poly = stroke.result;
                if (poly.type === 'line') {
                    if (pointToSegmentDist(x, y, poly.start, poly.end) < threshold) return true;
                } else if (poly.type === 'circle') {
                    const dist = Math.abs(Math.hypot(x - poly.center[0], y - poly.center[1]) - poly.radius);
                    if (dist < threshold) return true;
                } else if (poly.vertices) {
                    for (let i = 0; i < poly.vertices.length; i++) {
                        const next = (i + 1) % poly.vertices.length;
                        if (pointToSegmentDist(x, y, poly.vertices[i], poly.vertices[next]) < threshold) return true;
                    }
                }
            }
            
            return false;
        }

        function pointToSegmentDist(px, py, p1, p2) {
            const dx = p2[0] - p1[0];
            const dy = p2[1] - p1[1];
            const len2 = dx * dx + dy * dy;
            if (len2 === 0) return Math.hypot(px - p1[0], py - p1[1]);
            let t = ((px - p1[0]) * dx + (py - p1[1]) * dy) / len2;
            t = Math.max(0, Math.min(1, t));
            const projX = p1[0] + t * dx;
            const projY = p1[1] + t * dy;
            return Math.hypot(px - projX, py - projY);
        }

        function eraseAtPoint(x, y) {
            const threshold = ERASER_RADIUS / zoom;
            let erased = false;
            for (let i = allStrokes.length - 1; i >= 0; i--) {
                if (pointNearStroke(x, y, allStrokes[i], threshold)) {
                    allStrokes.splice(i, 1);
                    erased = true;
                }
            }
            if (erased) {
                if (editingStrokeIdx >= allStrokes.length) {
                    editingStrokeIdx = -1;
                    editMode = false;
                }
                draw();
            }
            return erased;
        }

        function updateEraserCursor(clientX, clientY) {
            const r = canvas.getBoundingClientRect();
            const size = ERASER_RADIUS * 2;
            eraserCursor.style.width = size + 'px';
            eraserCursor.style.height = size + 'px';
            eraserCursor.style.left = (clientX - r.left - ERASER_RADIUS) + 'px';
            eraserCursor.style.top = (clientY - r.top - ERASER_RADIUS) + 'px';
        }

        function showEraserCursor() {
            eraserCursor.style.display = 'block';
        }

        function hideEraserCursor() {
            eraserCursor.style.display = 'none';
        }

        let dragStartState = null;

        function getPinchDistance() {
            const keys = Object.keys(activeTouches);
            if (keys.length < 2) return 0;
            const t1 = activeTouches[keys[0]];
            const t2 = activeTouches[keys[1]];
            return Math.hypot(t2.x - t1.x, t2.y - t1.y);
        }

        function getPinchCenter() {
            const keys = Object.keys(activeTouches);
            if (keys.length < 2) return { x: 0, y: 0 };
            const t1 = activeTouches[keys[0]];
            const t2 = activeTouches[keys[1]];
            return { x: (t1.x + t2.x) / 2, y: (t1.y + t2.y) / 2 };
        }

        canvas.addEventListener('pointerdown', e => {
            e.preventDefault();
            
            activeTouches[e.pointerId] = { x: e.clientX, y: e.clientY };
            const touchCount = Object.keys(activeTouches).length;
            
            if (touchCount === 2) {
                isPinching = true;
                lastPinchDist = getPinchDistance();
                lastPinchCenter = getPinchCenter();
                currentPoints = [];
                if (activePointerId !== null) {
                    try { canvas.releasePointerCapture(activePointerId); } catch(ex) {}
                }
                activePointerId = null;
                isErasing = false;
                hideEraserCursor();
                draw();
                return;
            }
            
            if (activePointerId !== null && activePointerId !== e.pointerId) return;
            
            activePointerId = e.pointerId;
            try { canvas.setPointerCapture(e.pointerId); } catch(ex) {}
            
            const [x, y] = toCanvas(e.clientX, e.clientY);
            lastX = e.clientX;
            lastY = e.clientY;
            
            if (currentTool === 'eraser') {
                isErasing = true;
                showEraserCursor();
                updateEraserCursor(e.clientX, e.clientY);
                eraseAtPoint(x, y);
                return;
            }
            
            if (e.shiftKey) {
                panning = true;
                return;
            }
            
            if (editMode && editingStrokeIdx >= 0) {
                dragging = findControlPoint(x, y);
                if (dragging) {
                    dragStartState = JSON.stringify({
                        allStrokes: allStrokes,
                        editMode: editMode,
                        editingStrokeIdx: editingStrokeIdx,
                        currentTool: currentTool
                    });
                }
                if (!dragging) panning = true;
            } else {
                currentPoints = [[x, y]];
                lastMove = Date.now();
                draw();
            }
        });

        canvas.addEventListener('pointermove', e => {
            e.preventDefault();
            
            if (activeTouches[e.pointerId]) {
                activeTouches[e.pointerId] = { x: e.clientX, y: e.clientY };
            }
            
            // 橡皮擦工具时显示光标
            if (currentTool === 'eraser' && !isPinching) {
                showEraserCursor();
                updateEraserCursor(e.clientX, e.clientY);
            }
            
            if (isPinching && Object.keys(activeTouches).length >= 2) {
                const newDist = getPinchDistance();
                const newCenter = getPinchCenter();
                const scale = window.devicePixelRatio || 2;
                
                if (lastPinchDist > 0 && newDist > 0) {
                    const zoomFactor = newDist / lastPinchDist;
                    const rect = canvas.getBoundingClientRect();
                    const cx = (lastPinchCenter.x - rect.left) * scale;
                    const cy = (lastPinchCenter.y - rect.top) * scale;
                    
                    const [ox, oy] = [(cx - offsetX) / zoom / scale, (cy - offsetY) / zoom / scale];
                    zoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
                    offsetX = cx - ox * zoom * scale;
                    offsetY = cy - oy * zoom * scale;
                }
                
                const dx = newCenter.x - lastPinchCenter.x;
                const dy = newCenter.y - lastPinchCenter.y;
                offsetX += dx * scale;
                offsetY += dy * scale;
                
                lastPinchDist = newDist;
                lastPinchCenter = newCenter;
                document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
                draw();
                return;
            }
            
            if (activePointerId !== null && e.pointerId !== activePointerId) return;
            
            const [x, y] = toCanvas(e.clientX, e.clientY);
            
            if (isErasing && currentTool === 'eraser') {
                updateEraserCursor(e.clientX, e.clientY);
                eraseAtPoint(x, y);
                return;
            }
            
            if (panning) {
                const scale = window.devicePixelRatio || 2;
                offsetX += (e.clientX - lastX) * scale;
                offsetY += (e.clientY - lastY) * scale;
                lastX = e.clientX;
                lastY = e.clientY;
                draw();
            } else if (dragging && editingStrokeIdx >= 0) {
                const stroke = allStrokes[editingStrokeIdx];
                const d = dragging;
                
                if (d.type === 'bezier') {
                    stroke.result.segments[d.seg].controls[d.pt] = [x, y];
                    if (d.pt === 3 && d.seg < stroke.result.segments.length - 1) stroke.result.segments[d.seg + 1].controls[0] = [x, y];
                    if (d.pt === 0 && d.seg > 0) stroke.result.segments[d.seg - 1].controls[3] = [x, y];
                } else if (d.type === 'circle_center') {
                    const geo = stroke.result;
                    const dx = x - geo.params[0], dy = y - geo.params[1];
                    geo.params[0] = x; geo.params[1] = y;
                    geo.center = [x, y];
                    geo.startEnd[0] += dx; geo.startEnd[1] += dy;
                } else if (d.type === 'circle_startEnd') {
                    const geo = stroke.result;
                    const cx = geo.params[0], cy = geo.params[1];
                    geo.params[2] = Math.hypot(x - cx, y - cy);
                    geo.radius = geo.params[2];
                    const ang = Math.atan2(y - cy, x - cx);
                    geo.startEnd = [cx + geo.radius * Math.cos(ang), cy + geo.radius * Math.sin(ang)];
                } else if (d.type === 'ellipse_focus') {
                    stroke.result.foci[d.idx] = [x, y];
                    updateEllipse(stroke.result);
                } else if (d.type === 'ellipse_startEnd') {
                    const geo = stroke.result;
                    const [h, k, a, b, theta] = geo.params;
                    const ang = Math.atan2(y - k, x - h) - theta;
                    geo.startEnd = [h + a*Math.cos(ang)*Math.cos(theta) - b*Math.sin(ang)*Math.sin(theta), k + a*Math.cos(ang)*Math.sin(theta) + b*Math.sin(ang)*Math.cos(theta)];
                } else if (d.type === 'parabola_vertex') {
                    stroke.result.vertex = [x, y];
                    updateParabola(stroke.result);
                } else if (d.type === 'parabola_start') {
                    stroke.result.start = [x, y];
                    updateParabola(stroke.result);
                } else if (d.type === 'parabola_end') {
                    stroke.result.end = [x, y];
                    updateParabola(stroke.result);
                } else if (d.type === 'line_start') {
                    stroke.result.start = [x, y];
                } else if (d.type === 'line_end') {
                    stroke.result.end = [x, y];
                } else if (d.type === 'poly_circle_center') {
                    stroke.result.center = [x, y];
                } else if (d.type === 'poly_center') {
                    const dx = x - stroke.result.center[0], dy = y - stroke.result.center[1];
                    stroke.result.center = [x, y];
                    for (let v of stroke.result.vertices) { v[0] += dx; v[1] += dy; }
                } else if (d.type === 'poly_vertex') {
                    const poly = stroke.result;
                    const cx = poly.center[0], cy = poly.center[1];
                    poly.radius = Math.hypot(x - cx, y - cy);
                    poly.rotation = Math.atan2(y - cy, x - cx) - 2 * Math.PI * d.idx / poly.sides;
                    updatePolygon(poly);
                }
                draw();
            } else if (!editMode && currentPoints.length > 0 && activePointerId !== null && !isPinching) {
                const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
                for (const ce of events) {
                    const [cx, cy] = toCanvas(ce.clientX, ce.clientY);
                    currentPoints.push([cx, cy]);
                }
                lastMove = Date.now();
                draw();
            }
        });

        canvas.addEventListener('pointerup', async e => {
            e.preventDefault();
            
            delete activeTouches[e.pointerId];
            const touchCount = Object.keys(activeTouches).length;
            
            if (isPinching && touchCount < 2) {
                isPinching = false;
                lastPinchDist = 0;
                if (touchCount === 1) {
                    const remainingId = Object.keys(activeTouches)[0];
                    activePointerId = parseInt(remainingId);
                    lastX = activeTouches[remainingId].x;
                    lastY = activeTouches[remainingId].y;
                    panning = true;
                }
                return;
            }
            
            if (e.pointerId !== activePointerId) return;
            
            if (isErasing) {
                isErasing = false;
                saveState();
                activePointerId = null;
                try { canvas.releasePointerCapture(e.pointerId); } catch(ex) {}
                return;
            }
            
            if (dragging && dragStartState) {
                const currentState = JSON.stringify({
                    allStrokes: allStrokes,
                    editMode: editMode,
                    editingStrokeIdx: editingStrokeIdx,
                    currentTool: currentTool
                });
                historyStack = historyStack.slice(0, historyIndex + 1);
                historyStack.push(currentState);
                if (historyStack.length > MAX_HISTORY) {
                    historyStack.shift();
                }
                historyIndex = historyStack.length - 1;
                dragStartState = null;
            }
            
            if (!editMode && currentPoints.length > 2 && !panning) {
                if (currentTool === 'freehand') {
                    allStrokes.push({
                        tool: 'freehand',
                        points: [...currentPoints],
                        result: null,
                        color: freehandColor
                    });
                    saveState();
                    status.textContent = t('statusFreehand');
                } else if (Date.now() - lastMove >= 500) {
                    let result = null;
                    if (currentTool === 'bezier') {
                        const res = await fetch('/fit', {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({points: currentPoints})});
                        result = await res.json();
                        status.textContent = `${t('fitted')} ${result.segments.length} ${t('segments')}`;
                    } else if (currentTool === 'geometry') {
                        const res = await fetch('/fit_geometry', {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({points: currentPoints})});
                        result = await res.json();
                        status.textContent = `${t('recognized')}: ${result.type}`;
                    } else if (currentTool === 'polygon') {
                        const res = await fetch('/fit_polygon', {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({points: currentPoints})});
                        result = await res.json();
                        status.textContent = `${t('recognized')}: ${result.type}`;
                    }
                    if (result) {
                        allStrokes.push({
                            tool: currentTool,
                            points: [...currentPoints],
                            result: result,
                            color: null
                        });
                        saveState();
                    }
                }
                updateButtons();
            }
            
            currentPoints = [];
            dragging = null;
            panning = false;
            activePointerId = null;
            try { canvas.releasePointerCapture(e.pointerId); } catch(ex) {}
            draw();
        });

        canvas.addEventListener('pointercancel', e => {
            delete activeTouches[e.pointerId];
            if (Object.keys(activeTouches).length < 2) {
                isPinching = false;
            }
            if (e.pointerId === activePointerId) {
                activePointerId = null;
                dragging = null;
                panning = false;
                currentPoints = [];
                dragStartState = null;
                isErasing = false;
            }
        });

        canvas.addEventListener('pointerleave', e => {
            delete activeTouches[e.pointerId];
            if (Object.keys(activeTouches).length < 2) {
                isPinching = false;
            }
            if (currentTool === 'eraser') {
                hideEraserCursor();
            }
        });

        canvas.addEventListener('pointerenter', e => {
            if (currentTool === 'eraser') {
                showEraserCursor();
                updateEraserCursor(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('touchstart', e => e.preventDefault(), {passive: false});
        canvas.addEventListener('touchmove', e => e.preventDefault(), {passive: false});
        canvas.addEventListener('touchend', e => e.preventDefault(), {passive: false});

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const [ox, oy] = toCanvas(e.clientX, e.clientY);
            const scale = window.devicePixelRatio || 2;
            const rect = canvas.getBoundingClientRect();
            const cx = (e.clientX - rect.left) * scale;
            const cy = (e.clientY - rect.top) * scale;
            
            zoom = Math.max(0.1, Math.min(5, zoom * (e.deltaY > 0 ? 0.9 : 1.1)));
            offsetX = cx - ox * zoom * scale;
            offsetY = cy - oy * zoom * scale;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            draw();
        }, {passive: false});

        function findLastStrokeOfTool(tool) {
            for (let i = allStrokes.length - 1; i >= 0; i--) {
                if (allStrokes[i].tool === tool && allStrokes[i].result) return i;
            }
            return -1;
        }

        document.getElementById('clear').onclick = () => {
            allStrokes = [];
            currentPoints = [];
            editMode = false;
            editingStrokeIdx = -1;
            zoom = 1;
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;
            document.getElementById('zoomLevel').textContent = '100%';
            colorPickerDiv.classList.remove('show');
            colorPickerVisible = false;
            status.textContent = t('statusCleared');
            saveState();
            updateButtons();
            draw();
        };

        document.getElementById('undo').onclick = undo;
        document.getElementById('redo').onclick = redo;

        document.getElementById('mode').onclick = () => {
            if (currentTool === 'bezier') {
                const idx = findLastStrokeOfTool('bezier');
                if (idx >= 0) {
                    editMode = !editMode;
                    editingStrokeIdx = editMode ? idx : -1;
                }
            } else {
                currentTool = 'bezier';
                editMode = false;
                editingStrokeIdx = -1;
                colorPickerDiv.classList.remove('show');
                colorPickerVisible = false;
                status.textContent = t('statusCurve');
            }
            hideEraserCursor();
            updateButtons();
            draw();
        };

        document.getElementById('geometry').onclick = () => {
            if (currentTool === 'geometry') {
                const idx = findLastStrokeOfTool('geometry');
                if (idx >= 0) {
                    editMode = !editMode;
                    editingStrokeIdx = editMode ? idx : -1;
                }
            } else {
                currentTool = 'geometry';
                editMode = false;
                editingStrokeIdx = -1;
                colorPickerDiv.classList.remove('show');
                colorPickerVisible = false;
                status.textContent = t('statusConic');
            }
            hideEraserCursor();
            updateButtons();
            draw();
        };

        document.getElementById('polygon').onclick = () => {
            if (currentTool === 'polygon') {
                const idx = findLastStrokeOfTool('polygon');
                if (idx >= 0) {
                    editMode = !editMode;
                    editingStrokeIdx = editMode ? idx : -1;
                }
            } else {
                currentTool = 'polygon';
                editMode = false;
                editingStrokeIdx = -1;
                colorPickerDiv.classList.remove('show');
                colorPickerVisible = false;
                status.textContent = t('statusPolygon');
            }
            hideEraserCursor();
            updateButtons();
            draw();
        };

        document.getElementById('freehand').onclick = () => {
            if (currentTool === 'freehand') {
                colorPickerVisible = !colorPickerVisible;
                colorPickerDiv.classList.toggle('show', colorPickerVisible);
            } else {
                currentTool = 'freehand';
                editMode = false;
                editingStrokeIdx = -1;
                colorPickerVisible = false;
                colorPickerDiv.classList.remove('show');
                status.textContent = t('statusFreehandTip');
            }
            hideEraserCursor();
            updateButtons();
            draw();
        };

        document.getElementById('eraser').onclick = () => {
            currentTool = 'eraser';
            editMode = false;
            editingStrokeIdx = -1;
            colorPickerDiv.classList.remove('show');
            colorPickerVisible = false;
            status.textContent = t('statusEraser');
            updateButtons();
            draw();
        };

        document.getElementById('toggleStroke').onclick = () => {
            showStroke = !showStroke;
            document.getElementById('toggleStroke').textContent = showStroke ? t('hideStroke') : t('showStroke');
            draw();
        };

        document.getElementById('zoomIn').onclick = () => {
            const cx = canvas.width / 2, cy = canvas.height / 2;
            const scale = window.devicePixelRatio || 2;
            const [ox, oy] = [(cx - offsetX) / zoom / scale, (cy - offsetY) / zoom / scale];
            zoom = Math.min(5, zoom * 1.3);
            offsetX = cx - ox * zoom * scale;
            offsetY = cy - oy * zoom * scale;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            draw();
        };

        document.getElementById('zoomOut').onclick = () => {
            const cx = canvas.width / 2, cy = canvas.height / 2;
            const scale = window.devicePixelRatio || 2;
            const [ox, oy] = [(cx - offsetX) / zoom / scale, (cy - offsetY) / zoom / scale];
            zoom = Math.max(0.1, zoom / 1.3);
            offsetX = cx - ox * zoom * scale;
            offsetY = cy - oy * zoom * scale;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            draw();
        };

        document.getElementById('resetZoom').onclick = () => {
            zoom = 1;
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;
            document.getElementById('zoomLevel').textContent = '100%';
            draw();
        };

        document.getElementById('langBtn').onclick = () => {
            lang = lang === 'en' ? 'zh' : 'en';
            updateLanguage();
        };

        updateLanguage();
    </script>
</body>
</html>